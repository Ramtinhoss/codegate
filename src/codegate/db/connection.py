import asyncio
import datetime
import uuid
from pathlib import Path
from typing import Optional

import structlog
from litellm import ChatCompletionRequest
from sqlalchemy import create_engine, text
from sqlalchemy.ext.asyncio import create_async_engine

from codegate.db.models import Prompt

logger = structlog.get_logger("codegate")


class DbRecorder:

    def __init__(self, sqlite_path: Optional[str] = None):
        # Initialize SQLite database engine with proper async URL
        if not sqlite_path:
            current_dir = Path(__file__).parent
            self._db_path = (current_dir.parent.parent.parent / "codegate.db").absolute()
        else:
            self._db_path = Path(sqlite_path).absolute()

        logger.debug(f"Initializing DB from path: {self._db_path}")
        engine_dict = {
            "url": f"sqlite+aiosqlite:///{self._db_path}",
            "echo": True,  # Set to False in production
            "isolation_level": "AUTOCOMMIT",  # Required for SQLite
        }
        self._async_db_engine = create_async_engine(**engine_dict)
        self._db_engine = create_engine(**engine_dict)

        if not self.does_db_exist():
            logger.info(f"Database does not exist at {self._db_path}. Creating..")
            asyncio.run(self.init_db())

    def does_db_exist(self):
        return self._db_path.is_file()

    async def init_db(self):
        """Initialize the database with the schema."""
        if self.does_db_exist():
            logger.info("Database already exists. Skipping initialization.")
            return

        # Get the absolute path to the schema file
        current_dir = Path(__file__).parent
        schema_path = current_dir.parent.parent.parent / "sql" / "schema" / "schema.sql"

        if not schema_path.exists():
            raise FileNotFoundError(f"Schema file not found at {schema_path}")

        # Read the schema
        with open(schema_path, "r") as f:
            schema = f.read()

        try:
            # Execute the schema
            async with self._async_db_engine.begin() as conn:
                # Split the schema into individual statements and execute each one
                statements = [stmt.strip() for stmt in schema.split(";") if stmt.strip()]
                for statement in statements:
                    # Use SQLAlchemy text() to create executable SQL statements
                    await conn.execute(text(statement))
        finally:
            await self._async_db_engine.dispose()

    async def record_request(
        self, normalized_request: ChatCompletionRequest, is_fim_request: bool, provider_str: str
    ) -> Optional[Prompt]:
        # Extract system prompt and user prompt from the messages
        messages = normalized_request.get("messages", [])
        system_prompt = []
        user_prompt = []

        for msg in messages:
            if msg.get("role") == "system":
                system_prompt.append(msg.get("content"))
            elif msg.get("role") == "user":
                user_prompt.append(msg.get("content"))

        # If no user prompt found in messages, try to get from the prompt field
        # (for non-chat completions)
        if not user_prompt:
            prompt = normalized_request.get("prompt")
            if prompt:
                user_prompt.append(prompt)

        if not user_prompt:
            logger.warning("No user prompt found in request.")
            return None

        # Create a new prompt record
        prompt_params = Prompt(
            id=str(uuid.uuid4()),  # Generate a new UUID for the prompt
            timestamp=datetime.datetime.now(datetime.timezone.utc),
            provider=provider_str,
            type="fim" if is_fim_request else "chat",
            user_prompt="<|>".join(user_prompt),
            system_prompt="<|>".join(system_prompt),
        )
        # There is a `create_prompt` method in queries.py automatically generated by sqlc
        # However, the method is is buggy and doesn't work as expected.
        # Manually writing the SQL query to insert the prompt record.
        async with self._async_db_engine.begin() as conn:
            sql = text(
                """
                INSERT INTO prompts (id, timestamp, provider, system_prompt, user_prompt, type)
                VALUES (:id, :timestamp, :provider, :system_prompt, :user_prompt, :type)
                RETURNING *
                """
            )
            result = await conn.execute(sql, prompt_params.model_dump())
            row = result.first()
            if row is None:
                return None

            return Prompt(
                id=row.id,
                timestamp=row.timestamp,
                provider=row.provider,
                system_prompt=row.system_prompt,
                user_prompt=row.user_prompt,
                type=row.type,
            )


def init_db_sync():
    """DB will be initialized in the constructor in case it doesn't exist."""
    DbRecorder()


if __name__ == "__main__":
    init_db_sync()
